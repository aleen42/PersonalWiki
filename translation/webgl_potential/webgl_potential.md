## The WebGL potential - WebGL的潜力 [**Back**](./../translation.md)

> * 原文链接 : [The WebGL potential](http://typedarray.org/the-webgl-potential/)
* 原文作者 : [typedarray.org](http://typedarray.org/)
* 译者 : [aleen42](https://github.com/aleen42) 
* 校对者 : 暂无
* 状态 : 待校对

### WebGL的潜力

&#160; &#160; &#160; &#160;最近，关于 WebGL 将广泛兼容于各平台的谣言炙手可热，尤其是 IE 浏览器。当然，随着谣言的传递，一组真正可跨平台的 GPU API 也随即面世。在我看来，倘若谣言得以实现，那么这将会在一定程度上影响到 Web 开发中的许多观念。在关于人们如何开发交互性内容的观念上，这影响显得尤为明显。当然，即便这只是一个谣言，我也希望它能推动 Web 开发领域的发展。

#### 使用 WebGL 也可以处理二维图像

<p align="center"><img src="./grotto-uv.png"></p>

&#160; &#160; &#160; &#160;[WebGL](http://www.khronos.org/webgl/) 是一组针对 OpenGL ES 2.0 功能集所开放的基本 JavaScript 底层接口（其背后实际上运用了 OpenGL/ES 2.0 或 DirectX 的技术）。然而，大家却误以为 WebGL 仅仅可以处理三维图像。其实，我们不仅能像 [three.js](https://github.com/mrdoob/three.js/) 那样，利用这些底层接口重构出三维图像中的高级结构。而且，还能简化二维图像中的基元，以便我们去处理二维图像。众所周知，两个三角形便能够形成一个矩形，且该矩形能承载一段纹理内容。而这便是 GPU 加速渲染二维图形的原理。此外，当 WebGL 无法力所能及的时候，这也是诸如 [Cocos2D-x](http://www.cocos2d-x.org/) 或 [Pixi.js](https://github.com/GoodBoyDigital/pixi.js) 等大部分二维图形框架基于 Canvas 的一种回退机制。也许你会问，若我想实现复杂的滤波或颗粒度效果呢？对此，WebGL 也提供了一种可编程管道（着色块（shader））的方式，以实现图像的可再生化（reproducible ）。

&#160; &#160; &#160; &#160;曾几何时，我们[在 Flash 中开发 Stage3D 库时](http://www.youtube.com/watch?v=c0IwvN4IdH4)，便想着要尽可能地去暴露底层的接口，以使得开发者可以从顶层灵活地开发框架。特别是对于游戏开发者来说，他们过往曾迫切需要通过区分颗粒度的等级来一切，并获得超乎想象的高性能。另一方面，我们了解到大部分开发者会热衷于使用他们熟悉的高级别 API 分离基元，而不是低级别的 GPU 基元。因此，我们创造出了 [Starling](http://gamua.com/starling)。它可以基于 Stage3D 之上，快速成为二维图像内容的框架。Rivio 通过使用该框架，把 [Angry Birds](https://apps.facebook.com/angrybirds/?fb_source=timeline) 装载于 Facebook 中。此外，Zynga 最近也通过该框架装载了 [Ruby Blast](https://apps.facebook.com/rubyblast/?fb_source=search&ref=ts&fref=ts)。

&#160; &#160; &#160; &#160;除了帮助游戏开发之外， WebGL还能推动了交互的体验以及部分的数字化营销页面，像为人熟知多年的 [thefwa.com](http://www.thefwa.com/) 和传统通过 Flash 实现交互的交付物。不仅如此，它还彻底变更了开发者构件移动端应用的方式。所有你在手机上所能欣赏到的平缓 UI 组件，全都是通过 GPU 加速的，且由 OpenGL ES 2.0（iOS、Android）或 DirectX（Windows 8）所提供服务支持。当然，我希望能有越来越多的 UI 框架出现，以提供基于 WebGL 上通过 GPU 快速加速的 UI 组件。[Feathers](http://feathersui.com/) 就是一个很好的例子。

&#160; &#160; &#160; &#160;这意味着我们都通过 WebGL 去完成所有的事情？并不是，这取决于实际的情况。对于多文本内容来说，使用一个由 CSS 定义样式的传统 DOM，会更加的有效，像一个新闻页面、一个论坛或简单的表单应用。CPU 是善于处理像字体编译或矩阵计算等其他事情。因此，如果我们能结合好两者（基于 CPU 或 GPU 的编译器），这将会是一个很强大的混合。

#### 隐式 vs 显式

&#160; &#160; &#160; &#160;如今，为了在浏览器中获得更高的性能，各种技术都被构建成一种欺诈系统的技术。在 Stackoverflow 上看到关于性能欺诈的谈话时，我不禁感到有点恐怖。因为，你会因为你的臆想，或更坏情况下所产生的副作用，使得你的项目终结。在过去的几年，关于对 DOM 使用 GPU 加速的一些神奇方案，过去几年人们都有很多的言论。可是，想要产生有效的加速是非常的难。为什么？因为一个显示列表允许了许多东西的呈现，而这些东西在 GPU 上是很难实现有效加速的。复杂的嵌套、蒙层、混合以及能通过 JavaScript 或 CSS 可控的，都很难实现加速。随着开发者尝试在浏览器上，去写这些所谓神奇的代码来加速 DOM 元素。使用到这些代码的你，或许会对此产生臆想或异常，因为这不可能覆盖到成千上万可能会遇到的用例。而这点也使得如今开发者很难在它们的表面上开发内容。那些你无法控制的东西在幕后悄然发生，这将使得你的开发终止于所谓的伏都优化和鸡骨头似的建议像：

*使用这些属性，你需要确保美欧嵌套任何东西，而且确保 alpha 值已设置成零，并保证不要从 DOM 结构中移除该元素。*

&#160; &#160; &#160; &#160;其实，你所需要的是揭露出来的低级别基元（像 WebGL），并使得人们可以开发更高级别的框架。这也是最灵活的一种模型。倘若你是有性能上的问题或者漏洞，那么你可以去修复它。而如果你不喜欢一个框架的结构，拿就替换它。因为所有的代码都是基于内容的，而不是基于浏览器。这就是项目 [DOM.js](https://github.com/andreasgal/dom.js/) 背后的思想。

&#160; &#160; &#160; &#160;最近有那么一个案例，那就是通过使用 <a href="http://msdn.microsoft.com/en-us/library/ie/jj200289(v=vs.85).aspx" target="_blank">translateZ</a>（CSS3）去强制 GPU 进行加速。在这里，我再重新强调一次的是，该方法属于一个非法侵入的方法，且具有副作用。该方法原本是开发用于三维图像效果，但开发者如今只用在二维效果上，而没真正了解到在幕后所发生的隐式事件。其实在背后，你想要加速的 DOM 元素会进行点阵化（一般如果该元素拥有很多的内嵌子元素，那么，这简单的第一步将会是很耗时），然后，位图会在幕后被上传至 GPU （要记住你是无法调用任何的上传 API）。此后，才重新混合于页面中。顺便说一下的是，如果纹理是非常得大，那么它将会挫击在内存外运行的其他设备，并使得开发者坠入黑暗。

&#160; &#160; &#160; &#160;再次强调，通过低级别基元，你可以允许高级开发者开发高级别的框架（在这里指的是使用 JavaScript 语言），然后给其他开发者一个使用 API 的机会去了解这些基元在背后的显式事件，而这过程仅带有最小化的副作用。尝试使用这些高级框架去解决事情的人，他们有一个机会能看到背后的实现，并了解哪里存在有问题，且背后到底是如何工作的。作为一个 Flash 开发者，他们开发相似技术，如使用 cacheAsBitmap 去使得代码运行更快这事情已经并非是一件新鲜的事情。再次强调，使用这项技术是一把双刃剑。这看起来或许像是纸上谈兵，但一旦你开始使用 cacheAsBitmap，你就会意识到该 API 是有多鬼祟。而且在其上面有效地构建东西将是多难的事情。我曾经在很久之前写过一篇文章来阐述为何 cacheAsBitmap 是一个邪恶的东西，而且相似的结果，我们能用低级的基元以最小化副作用去完成。

#### 高级框架的重要性

<img src="./logo-300x1441.png">

&#160; &#160; &#160; &#160;大部分开发者或许不会潜入 WebGL 中 GPU 编程的细节上。相反，人们会寻找一些带有熟悉结构的高级框架，去使得产品完成且具有最好的效能。这些框架将会是非常得重要，这是因为 WebGL 对于 web 开发者来说，并不是一个友善的 API。实际上，它只是从90年代的（OpenGL）水平面直接引用到 JavaScript。

&#160; &#160; &#160; &#160;GPU 编程不仅会是件很艰难的事情，除此之外，WebGL 所提供的 API 入口时非常得巨大，以至于以脚本形式去运行或捕获错误的过程变得非常冗长和复杂。这对于大部分的 web 开发者来说，是很不自然的一件事情。但是，好消息在于，基于 WebGL 上已经有大量已经编写好的 JavaScript 框架如雨后春笋般出现，以至于有大量的选择提供给开发者使用。

#### 这仍然是 web 吗？

&#160; &#160; &#160; &#160;就像2D Canvas 一样，WebGL 也会给 canvas 内部的所有东西提供支持，这使得 canvas 变成了一个相当隐秘的黑盒。这种模型对于游戏或部分交互模块来说是可接受的，而这一般对于搜索引擎优化来说却是不友善或不可访问的。这将导致有那么一个问题，那就是随着越来越多像应用程序那样的二维交互内容是由 WebGL 支持，这些内容或许需要被访问。那怎么办？由于局限性的问题，目前还不能实现，但我认为这迟早是要改变的。这不禁产生了一个疑问，为什么只有经典的 DOM 元素 能被访问？

&#160; &#160; &#160; &#160;这里在此强调的是，WebGL 会创造新的方式去推动 web 的发展。

#### 推动 web 发展

<img src="./Unreal-Engine-UDK-11-300x187.jpg">

&#160; &#160; &#160; &#160;在 Flash 的 Stage3D 框架出现之前，主要的瓶颈位是图像通道的问题。ActionScript 3 是曾经能足够快地实现大部分的展示列表或依托 BitmapData 以位块去传输内容。但是，自从 Stage3D 的推出后，情况发生了改变。 ActionScript 3 对于开发者而言成为了一种限制。因此，开发者们开始开发高级框架，并把大量的昂贵代码移植出来。而其中的这些代码，在传统上来说，是仅能基于原生的 ActionScript 3 运行的。除此之外，原来的这些像树的遍历，边界或矩阵计算的代码等都只是运行在 ActionScript 3 层上。这将会给 VM 和 CPU 带来巨大的压力。

&#160; &#160; &#160; &#160;为了获得最好的性能，你会希望 CPU 和 GPU 能互相平行地协同运行。因为如果碰巧 CPU 资源占满，且 GPU 不能及时地处理过剩的计算，那么性能将会变得缓慢。使用 WebGL，同样的压力问题也会在 JavaScript 上出现。这就是为什么一开始像 [asm.js](http://asmjs.org/) 的库是需要被引用，但能够支持像 [Unreal engine](http://www.youtube.com/watch?feature=player_embedded&v=XsyogXtyU9o) 的引擎。这一点我希望能最终推进 JavaScript 性能的发展。你可以选择喜欢或不喜欢 asm.js，但它会尝试去解决与下一代内容密切相关的问题。

&#160; &#160; &#160; &#160;如果你对 asm.js 感兴趣，John Resig 刚为这写了一篇很好的[文章](http://ejohn.org/blog/asmjs-javascript-compile-target/)。

